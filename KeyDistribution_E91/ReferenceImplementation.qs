// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

//////////////////////////////////////////////////////////////////////
// This file contains reference solutions to all tasks.
// The tasks themselves can be found in Tasks.qs file.
// but feel free to look up the solution if you get stuck.
//////////////////////////////////////////////////////////////////////

namespace Quantum.Kata.KeyDistributionE91 {

    open Microsoft.Quantum.Arrays;
    open Microsoft.Quantum.Measurement;
    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Diagnostics;
    open Microsoft.Quantum.Convert;
    open Microsoft.Quantum.Math;
    open Microsoft.Quantum.Random;


    //////////////////////////////////////////////////////////////////
    // Part I. Preparation
    //////////////////////////////////////////////////////////////////
	
    // Task 1.1. Entangled Pairs
    operation EntangledPairs_Reference (qsAlice : Qubit[], qsBob : Qubit[]) : Unit {
        Fact(Length(qsAlice) == Length(qsBob), "Alice and Bob should have the same number of qubits");

        for i in IndexRange(qsAlice) {
            H(qsAlice[i]);
            CNOT(qsAlice[i], qsBob[i]);
        }
    }


    //////////////////////////////////////////////////////////////////
    // Part II. E91 Protocol
    //////////////////////////////////////////////////////////////////

    // Task 2.1 Rotate and Measure
    operation RotateAndMeasure_Reference (q : Qubit, rotationMultiplier: Int) : Result {
        mutable result = Zero;
        let rotationAngle = PI() * IntAsDouble(rotationMultiplier) / 4.0;

        within {
            Ry(rotationAngle, q);
        } apply {
            set result = M(q);
        }

        return result;
    }

    // Task 2.2 Measure Qubit Arrays
    operation MeasureQubitArray_Reference (qs: Qubit[], basisList: Int[]) : (Int[], Result[]) {
        mutable results = new Result[0];
        mutable bases = new Int[0];

        for q in qs {
            let basis = basisList[DrawRandomInt(0,2)];
            let res = RotateAndMeasure(q, basis);

            set bases += [basis];
            set results += [res];
        }

        return (bases, results);

    }

    // Task 2.3 Generate the shared key
    function GenerateSharedKey_Reference (basesAlice: Int[], basesBob: Int[], results: Result[]) : Bool[] {
        mutable key = new Bool[0];

        for (a, b, r) in Zipped3(basesAlice, basesBob, results) {
            if a == b {
                set key += [ResultAsBool(r)];
            }
        }
        
        return key;
    }

    // Task 2.4 CHSH Correlation Check
    function CorrelationCheck_Reference (basesAlice: Int[], basesBob: Int[], resAlice: Result[], resBob: Result[]) : Double {
        mutable expectationValues = new Double[0];
        
        for (i, j) in [(0,1), (0, 3), (2, 1), (2, 3)] {
            mutable sum = 0;
            mutable counter = 0;

            for idx in IndexRange(basesAlice) {
                if basesAlice[idx] == i and basesBob[idx] == j {
                    if resAlice[idx] == resBob[idx] {
                        set sum += 1;
                    } else {
                        set sum -= 1;
                    }
                    set counter += 1;
                }
            }
            if counter == 0 {
                set expectationValues += [0.0];
            } else {
                set expectationValues += [IntAsDouble(sum)/IntAsDouble(counter)];
            }
        }

        let s = expectationValues[0] 
            -  expectationValues[1]
            + expectationValues[2] 
            + expectationValues[3]; 

        return s;
    }


    // Task 2.5 Putting it all together 
    @Test("QuantumSimulator")
    operation T25_E91Protocol_Reference () : Unit {
        // 1. Alice and Bob choose basis multipliers
        let basisListAlice = [0, 1, 2];
        let basisListBob = [1, 2, 3];

        // 2. Alice and Bob are distributed arrays of entangled pairs
        let N = 13;
        use (qsAlice, qsBob) = (Qubit[N] ,Qubit[N]);
        EntangledPairs(qsAlice, qsBob);

        // 3. Measurements by Alice and Bob
        let (basesAlice, resAlice) = MeasureQubitArray(qsAlice, basisListAlice);
        let (basesBob, resBob) = MeasureQubitArray(qsBob, basisListBob);

        // 4. Keys generated by Alice and Bob
        let keyAlice = GenerateSharedKey(basesAlice, basesBob, resAlice);
        let keyBob = GenerateSharedKey(basesAlice, basesBob, resBob);
        Message($"Alice's Key: {keyAlice}");
        Message($"Bob's Key:   {keyBob}\n");

        // 5. Compute the CHSH correlation value
        let s = CorrelationCheck(basesAlice, basesBob, resAlice, resBob);
        Message($"S = {s}");

        // Reset all qubits to |0⟩
        ResetAll(qsAlice + qsBob);
        
    }

    //////////////////////////////////////////////////////////////////
    // Part III. Eavesdropping
    //////////////////////////////////////////////////////////////////

    // Task 3.1. Eavesdrop!
    operation Eavesdrop_Reference (qAlice : Qubit, qBob : Qubit, basis : Int) : (Result, Result) {
        Fact(basis == 1 or basis == 2, "Eve should measure in one of Alice's and Bob's compatible basis");

        let resAlice = RotateAndMeasure(qAlice, basis);
        let resBob = RotateAndMeasure(qBob, basis);

        return (resAlice, resBob);
    }

    // Task 3.2. Catch the eavesdropper
    @Test("QuantumSimulator")
    operation T32_E91ProtocolWithEavesdropper_Reference () : Unit {
        // 1. Alice and Bob choose basis multipliers
        let basisListAlice = [0, 1, 2];
        let basisListBob = [1, 2, 3];

        // 2. Alice and Bob are distributed arrays of entangled pairs
        let N = 13;
        use (qsAlice, qsBob) = (Qubit[N] ,Qubit[N]);
        EntangledPairs(qsAlice, qsBob);

        // Eve eavesdrops on all qubits, guessing the basis at random
        for (qAlice, qBob) in Zipped(qsAlice, qsBob) {
            let n = Eavesdrop(qAlice, qBob, DrawRandomInt(1,2));
        }

        // 3. Measurements by Alice and Bob
        let (basesAlice, resAlice) = MeasureQubitArray(qsAlice, basisListAlice);
        let (basesBob, resBob) = MeasureQubitArray(qsBob, basisListBob);

        // 4. Keys generated by Alice and Bob
        let keyAlice = GenerateSharedKey(basesAlice, basesBob, resAlice);
        let keyBob = GenerateSharedKey(basesAlice, basesBob, resBob);
        Message($"Alice's Key: {keyAlice}");
        Message($"Bob's Key:   {keyBob}\n");

        // 5. Compute the CHSH correlation value
        let s = CorrelationCheck(basesAlice, basesBob, resAlice, resBob);
        Message($"S = {s}");

        // Reset all qubits to |0⟩
        ResetAll(qsAlice + qsBob);

    }
}